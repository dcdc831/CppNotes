# 第十章 泛型算法

顺序容器只定义了很少操作，其他操作标准库定义了一组泛型算法（实现了一些算法的公共接口）。

## 10.1 概述

多数算法在algorithm头文件中，数值泛型算法在numeric中

一般情况下算法不直接对容器操作，而是遍历两个迭代器指定的范围

#### 算法如何工作

以find为例：

1. 访问序列首元素
2. 比较
3. 若匹配，则返回标识此元素的值
4. 否则进入下一元素，重复2、3
5. 达到序列尾部，停止
6. 若达到末尾，则应返回一个指出并未找到元素的值，这个值应该与3中返回的值相容

因此，只要有一个迭代器可以用于访问元素，find就不依赖于容器类型，只要有迭代器就行。

可以总结：算法不依赖于容器（由于有迭代器的存在），但是算法本身依赖于元素类型的操作。

算法无法执行容器的操作，泛型算法运行于迭代器之上，这就表明：算法不会改变底层容器的大小，不会直接添加和删除元素。

## 10.2 初识泛型算法

多数算法都是对一个范围内的元素进行操作，此元素范围为“输入范围”，用一对迭代器来划分此范围。

理解算法最基本的方法是了解他们是否读取元素、改变元素、重排元素

### 10.2.1 只读算法

如find, count, accumulate

#### 算法和元素类型

以accumulate为例，其将第三个参数作为求和起点，这隐含着：元素类型加到和的类型这个操作必须是已经被定义的。

`accumulate(v.cbegin(), v.cend, " ");//这是错误的，因为const char*没有定义+运算符，第三个参数应该修改为string(" ")`

#### 操作两个序列的算法

如equal

`equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());`

此算法要处理第一个序列的每个元素，假定每个元素在第二个序列中有与之对应的，因此它假定第二个序列至少与第一个序列一样长。

### 10.2.2 写容器元素的算法

使用这类算法时，必须确保序列原大小至少等于写入元素的数目。（算法不能扩张容器）

fill接受一对迭代器给定的范围，将其用值填满，因此只要传递的序列有效，就是安全的。

算法不对写操作进行检查，它假定写入指定元素是安全的

#### back_inserter

一种保证有足够元素容纳输出数据的方法：使用**插入迭代器**。

back_inserter是一个函数，接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器，通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。

如vec是一个空向量，则有以下方式可以向vec内添加元素：

`auto it = back_iterator(vec);`

`*it = 42;`

或

`fill_n(back_iterator(vec), 1, 42);`

#### 拷贝算法

拷贝也假定传递给copy的目的序列至少包含与输入序列一样多的元素。copy返回目的位置迭代器的值，即拷贝完成后下一位的位置。

多个算法也有各自的拷贝版本

如replace：

`replace(ilst.cbegin(), ilst.cend(), back_iterator(ivec), 0, 42);`

ivec包含0替换为42之后的ilst的拷贝。ilst不发生变化。

### 10.2.3 重排容器元素的算法

sort：利用元素类型的<运算符实现排序

unique：“消除”相邻重复项，返回一个指向不重复范围末尾的迭代器。unique不真正删除元素，只是覆写了重复元素的位置，使不重复元素出现在序列的开始部分。真正删除还是要依靠容器的操作如erase。

## 10.3 定制操作

很多算法会比较输入序列中的元素，默认情况下用元素类型的<或=运算符。标准库还为这些算法定义了额外版本，允许用自定义的操作代替默认运算符。

### 10.3.1 向算法传递函数

以sort为例，其可以接受第三个参数：**谓词**

标准库算法使用的谓词分为两类：一元谓词、二元谓词，区别是接受参数数量。

算法接受谓词后对输入序列中元素调用谓词，因此元素类型必须能转化为谓词的参数类型。

stable_sort：稳定排序算法，维持相等元素原有顺序

### 10.3.2 lambda表达式

 一个lambda表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数。

有一个返回类型、一个参数列表、一个函数体，可能定义在函数内部。必须使用尾置返回

`[capture list](parameter list) ->return type{function body}`

参数列表和返回类型可忽略。

返回类型忽略时：若函数体只是一个return语句，则返回类型由返回值推断；若函数体包含任何return之外的内容，则返回void。

lambda表达式可以用作谓词，捕获列表不属于接受的参数，因此在一定情况下一个参数的lambda表达式可以做到二元谓词的功能。

### 10.3.3 lambda捕获和返回

定义一个lambda时，编译器生成一个与lambda对应的心得未命名的类类型。

向一个函数传递lambda时，定义了一个新类型和该类型的对象，传递的参数是该类型的未命名对象。类似，使用auto定义一个lambda初始化的变量，定义了一个从lambda生成的类型的对象。lambda所捕获的变量作为该类的数据成员。

#### 值捕获

需要注意的是，被捕获的变量的值在lambda被创建时就拷贝了，假如创建后、调用前改变了该值，则对于lambda内部该值没有变化。

#### 引用捕获

以引用方式捕获变量时，保证lambda执行时变量存在。

我们可以从函数返回lambda，此时lambda不能包含引用捕获（局部变量在函数结束时就失效了）

一般来说，建议捕获简单化。

#### 隐式捕获

在捕获列表中写一个&或=

![image-20220715165037336](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220715165037336.png)

#### 可变lambda

默认情况下，值被拷贝的变量，lambda不会改变其值。如果希望改变一个被捕获的变量的值，在参数列表首（？）加上关键字mutable

`auto f = [v1]()mutable {return ++v1;};`

引用捕获的变量是否可以修改则取决于引用指向的时const类型还是非const类型。

### 10.3.4 参数绑定

有时我们需要一定数量参数的函数，但是所需形参又大于规定的形参数量，这时可以采用lambda，但在复用需求较多的情况下，使用lambda就不合适。因此我们引入bind函数。

#### 标准库bind函数

在头文件functional中。接受一个可调用对象，生成一个新的可调用对象适配原对象参数列表：

`auto newCallable = bind(callable, arg_list);`

调用newCallable时会调用callable并传入arg_list中的参数。

arg_list中可能包含形如_n的名字，n为整数。这些参数是占位符，占据了传递给newCallable的参数的位置。

例如check_size接受两个参数：const string&和int。假如要将其作为一元谓词，则：

`auto check6 = bind(check_size, _1, 6);`

此时可以调用：`check6(s)` 来代替`check_size(s, 6)`

#### 使用placeholder名字

_n定义在placeholders命名空间中，对应的声明可以写为：`using std::placeholders::_1`

当然也可以直接声明：`using namespace std::placeholders;`

#### bind重排参数顺序

bind占位符是对应顺序映射的，因此：

`sort(w.begin(), w.end(), bind(isShorter, _2, _1));//作用是由长到短排序，相当于重排的isShorter的参数顺序`

#### 绑定引用参数

bind拷贝其参数，若希望传递参数，则用ref函数，假如要传递一个ostream对象：

`bind(print, ref(os), _1, ' ');`

## 10.4 再探迭代器

- 插入迭代器
- 流迭代器
- 反向迭代器
- 移动迭代器

### 10.4.1 插入迭代器

是一种适配器，接受一个容器，生成一个迭代器，能在给定容器中添加元素

`it = t; // 在it指定位置插入t，调用的容器操作取决于it的类型`

插入其包括：

- back_inserter：创建一个使用push_back的迭代器
- front_inserter：push_front
- inserter：insert，接受第二个参数，这个参数是指向给定容器的迭代器，元素被插入到其所表示的元素之前

使用front_inserter插入时，每当有新元素被插到首位，首元素位置更新，因此最后插入的顺序会颠倒。

### 10.4.2 iostream迭代器

#### istream_iterator

使用>>读取流。

创建时，可以绑定到一个流，也可以默认初始化迭代器，创建了一个可以作为尾后值使用的迭代器。

允许**懒惰求值**

istream_iterator绑定到一个流时，标准库不保证迭代器立即从流读取数据。可以推迟从流读取数据，直到使用迭代器时才读取。

#### ostream_iterator

对任何具有输出运算符的类型定义ostream_iterator。创建时可以提供第二参数，是一个C风格字符串，在每个输出元素后面都会打印该字符串。

创建时必须绑定到一个指定流。

![image-20220715191729994](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220715191729994.png)

*out、++out、out++、out效果完全一致。但是，在循环中使用 *out++ 的形式可以使行为更加清晰，可读性高。

### 10.4.3 反向迭代器

从尾元素向首元素反向移动，递增递减操作含义会颠倒。除forward_list外都支持。

流迭代器不支持递减运算，所以不能从一个流迭代器创建反向迭代器

反向迭代器可以使用其成员函数base来完成向普通迭代器的转换。

## 10.5 泛型算法结构

算法的基本特性是其要求迭代器提供哪些操作。算法要求的迭代器操作可以分为五种类型：

![image-20220715195140387](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220715195140387.png)

### 10.5.1 5类迭代器

#### 迭代器类别

**输入迭代器**：读取序列中元素，必须支持：

- 比较相等和不等!=, ==
- 推进迭代器的前置、后置递增运算++
- 用于读取的解引用运算符*（解引用只会出现在运算符的右侧）
- 箭头运算符->

*it++可以保证有效，但是递增它可能导致其他指向流的迭代器失效。因此不保证输入迭代器的状态可以保存下来并用于访问元素。只能用于单遍扫描算法。

find、accumulate要求输入迭代器；istream_iterator是一种输入迭代器。

**输出迭代器**：只写而不读元素，必须支持：

- 推进迭代器的前置、后置递增运算++
- 用于写入的解引用运算符*（解引用只会出现在运算符的左侧）

copy的第三个参数就是输出迭代器；ostream_iterator是输出迭代器。

**前向迭代器**：可以读写，只能向一个方向移动。支持输入、输出迭代器的操作。可以保存向前迭代器的状态，对序列进行多遍扫描。

replace算法要求向前迭代器；forward_list上的迭代器是向前迭代器。

**双向迭代器**：还支持双向移动。除forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。

**随机访问迭代器**：提供常量时间内访问序列任意元素的能力。支持双向迭代器所有功能外还支持：

- 比较两个迭代器相对位置的关系运算符
- 迭代器和一个整数的加减运算，计算结果是迭代器向后或向前移动给定整数个元素后的位置
- 用于两个迭代器间的减法运算符，得到迭代器的距离
- 下标运算符iter[n]，与*(iter[n])等价

sort算法要求随机访问迭代器；array、deque、string、vector的迭代器都是，用于访问内置数组的指针也是随机访问迭代器

### 10.5.2 算法形参模式

`alg(beg, end, other args)`

`alg(beg, end, dest, other args)`

`alg(beg, end, beg2, other args)`

`alg(beg, end, beg2, end2, other args)`

- 接受单个目标迭代器的算法（第二个）

​		dest表示算法写入的目的位置的迭代器。算法假定按需要写入数据是安全的。

- 接受第二个输入序列的算法（第三第四个）

### 10.5.3 算法命名规范

1. 使用重载形式接受谓词，例如 sort、unique
2. _if版本算法，如 find_if是find的不同版本，其第三个参数接受谓词
3. 拷贝元素版本和不拷贝版本，例如reverse、reverse_copy（多接受一个目的位置的迭代器）
4. 部分同时提供 _copy、 _if版本，如remove_copy_if

## 10.6 特定容器算法

list、forward_list是链表类型，定义了几个成员函数形式的算法，比通用版本的算法效率更高。

![image-20220715201406952](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220715201406952.png)

#### splice成员

是链表数据结构特有的

<img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220715201751211.png" alt="image-20220715201751211" style="zoom:50%;" />

链表的特有操作可以改变容器。

