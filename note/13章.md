# 第十三章 拷贝控制

- 拷贝构造函数
- 拷贝赋值函数
- 移动构造函数
- 移动赋值运算符
- 析构函数

统称为拷贝控制函数

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

对class Foo来说

Foo();为默认构造函数

Foo(const Foo&); 为拷贝构造函数。此参数几乎总是一个const引用。通常不是explicit（因为通常拷贝构造函数都会被隐式使用）。

#### 合成拷贝构造函数

没有定义编译器会定义一个。即使我们定义了其他构造桉树，编译器也会合成一个。

一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。成员的类型决定了它如何拷贝。

![image-20220727212610475](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220727212610475.png)

#### 拷贝初始化

直接初始化和拷贝初始化的差异：直接初始化，实际上是要求编译器使用普通的函数匹配来选择与提供参数最匹配的构造函数；拷贝初始化，要求编译器将右侧运算对象拷贝到正在创建的对象中，可能进行类型转换。拷贝初始化也有时会使用移动构造函数完成。

拷贝初始化的其他发生情况：

![image-20220727213248057](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220727213248057.png)

调用insert或push时，拷贝初始化；调用emplace成员创建元素，直接初始化。

#### 参数和返回值

函数调用时，非引用类型的参数拷贝初始化。类似的，非引用的返回类型也是如此。

拷贝构造函数用来初始化非引用类类型参数。如果其参数不是引用类型，则调用会无限循环。

#### 编译器可以绕过拷贝构造函数

编译器可以跳过拷贝/移动构造函数，直接创建对象，如：

![image-20220727214303467](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220727214303467.png)

### 13.1.2 拷贝赋值运算符

如果未定义，编译器会为其合成一个拷贝赋值运算符。

#### 重载赋值运算符

本质上是函数。

`Foo& operator= (const Foo&);`为了与内置赋值一直，其常返回一个指向左侧运算对象的引用。标准库通常要求保存在容器中的类型要具有赋值运算符。

#### 合成拷贝赋值运算符

未定义时，编译器为其合成一个。有些类合成拷贝赋值运算符用于禁止该类型对象的赋值。

![image-20220727214900966](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220727214900966.png)

### 13.1.3 析构函数

释放对象使用的资源，销毁对象的非static数据成员。

`~Foo();`

析构函数不接受参数，因此它不能被重载。对一个给定类，只有一个析构函数。

#### 析构函数的工作

首先执行函数体，然后销毁成员，按初始化逆序销毁。

内置指针销毁时，不会delete所指对象；智能指针是类类型，智能指针成员在析构截断会被自动销毁。

#### 析构函数使用时机

![image-20220727221318600](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220727221318600.png)

#### 合成析构函数

有些类合成析构函数用于禁止该类型对象的被销毁。除此情况外，合成析构函数的函数体为空。

析构函数体自身不销毁成员，成员在析构函数体之后的隐含的析构截断中被销毁。

### 13.1.4 三/五法则

这3、5种操作常被看成整体，通常只需一种操作而不需要定义所有操作的情况是很少见的。

#### 需要析构函数的类也需要拷贝和赋值操作

![image-20220728100028472](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220728100028472.png)

合成的拷贝构造函数和拷贝赋值操作简单的拷贝指针成员，可能多个对象指向同一内存，这时多次自定义的析构，就会多次统一delete同一指针。造成错误。

#### 需要拷贝操作也需要赋值操作，反之亦然

### 13.1.5 使用=default

显示要求编译器生成合成的版本

类内使用时，合成的函数隐式地声明为内联的。

如不希望为内联，则要在类外定义使用=default。

### 13.1.6 阻止拷贝

组织拷贝不能不定义控制成员，因为编译器会为其合成版本。

#### 定义删除的函数

定义为删除的函数来阻止拷贝。在参数列表后面加上 =delete 来指明我们希望将其定义为删除的。

=delete必须出现在函数第一次声明的时候。可以对任何函数指定 =delete

#### 析构函数不能删除

对于一个删除析构函数的类型，编译器不允许定义该类型的变量或创建该类型临时对象。

#### 合成的拷贝控制成员可能是删除的

这些情况下：

- 类的某个成员的析构函数删除的或不可访问的。
- 类的某个成员构造函数是删除或不可访问的/类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数被定义为删除的。
- 类的某个成员的拷贝赋值运算符删除的或不可访问的，或类有一个const或引用成员，则类的合成拷贝运算符被定义为删除的。
- 类的某个成员的析构函数删除的或不可访问的，或类有一个引用成员，它没有类内初始化器，或类有一个const成员，他没有类内初始化器且其类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除的。

#### private拷贝控制

为阻止拷贝，也可以将这些拷贝控制成员声明为private的，同时不定义他们。

## 13.2 拷贝控制和资源管理

通常，管理类外资源的类必须定义拷贝控制成员。

类的行为可以像一个值或一个指针。

### 13.2.1 行为像值的类

![image-20220728111816255](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220728111816255.png)

定义拷贝赋值运算符时，需要注意防范自赋值操作的重要性。

### 13.2.2 定义行为像指针的类

拷贝指针本身而不是它指向的string。希望直接管理资源时，要使用引用计数。

#### 引用计数

![image-20220728113024095](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220728113024095.png)

计数器不能直接作为类对象的成员。可以将计数器保存在动态内存种，创建一个对象时，分配一个新的计数器。拷贝或赋值时，拷贝指向计数器的指针。

## 13.3 交换操作

如果类未定义swap，则算法会使用标准库定义的swap。

swap函数应该调用swap而不是std：：swap。若有特定类的swap，其匹配程度会优先于std的版本。

#### 赋值运算符中使用swap

拷贝并交换：

![image-20220728151834011](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220728151834011.png)

## 13.5 动态内存管理类

移动构造函数通常是将资源从给定对象移动而不是拷贝到正在创建的对象。

## 13.6 对象移动

### 13.6.1 右值引用

用&&来获得右值引用。右值引用只能绑定到一个快要销毁的对象。可以自由地将一个右值引用的资源移动到另一个对象中。

不能将一个右值引用直接绑定到一个左值上。

![image-20220728172841758](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220728172841758.png)

右值引用只能绑定到临时对象：

- 所引用的对象将被销毁
- 该对象没有其他用户

变量都是左值。

### 13.6.2 移动构造函数和移动赋值运算符

移动构造函数的例子：

![image-20220728201909251](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220728201909251.png)

移动构造函数不分配任何新内存。

#### 移动操作、标准库容器、异常

当编写一个不抛出异常的移动操作时，要通知标准库：

`StrVec(StrVec &&) noexcept;`

移动一个对象的过程中，如果移动了部分元素后抛出异常，就会出现问题。

#### 移动赋值运算符

![image-20220728203529817](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220728203529817.png)

#### 移后源对象必须可析构

当我们编写一个移动操作后，必须确保移后源对象进入一个可析构状态。

通常移后源对象的指针成员置为nullptr。

#### 合成的移动操作

只有一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为其合成移动操作。如果有成员是类类型且该类由相应的移动操作，则编译器也能移动这个成员。

移动操作永远不会隐式定义为删除的函数。

如果我们显示要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。

![image-20220728204853276](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220728204853276.png)

#### 移动右值，拷贝左值

用普通的函数匹配规则确定使用哪个构造函数。

在没有移动构造函数时，右值也被拷贝。

![image-20220728210439995](D:\2022暑期\C++ 2022级研\note\image-20220728210439995.png)

依赖于实参的类型，进行拷贝或移动。

#### 移动迭代器

标准库的make_move_iterator，解引用运算符生成一个右值引用，因此调用construct时使用移动构造函数来构造元素。
