# 第七章 类

类基本思想为数据抽象和封装

数据抽象：接口与实现分离的编程技术

​	接口：用户能执行的操作

​	实现：类的数据成员、负责接口实现的函数体、定义类所需的各种私有函数

## 7.1 定义抽象数据类型

**tips**：区分不同场景下的用户

- 定义成员函数
  - 成员函数可以通过隐式参数this来访问其调用的对象。total在调用成员isbn时传入了total的地址。
  - this总指向本指针，因此是一个常量指针。于本章例子中默认类型为 `Sales_data *const`.
  - 可以将this声明为`const Sales_data *const`类型，这样this可以绑定到常量对象上，用法更灵活。（**常量成员函数**）
  - 编译器处理类的顺序
    1. 编译成员的声明
    2. 成员函数体（因此成员函数体可以随意使用类中其他成员）
  - 在类外部定义成员函数时要使用作用域运算符。定义必须与其声明匹配。
  - 当定义的函数类似于内置运算符时，该函数的行为应尽量模仿该运算符。
- 构造函数
  - 构造函数不能被声明为const。创建类的const对象时，构造函数完成初始化过程后，对象才拥有常量属性。因此构造函数在const对象构造过程中可以向其写。
  - 默认构造函数：编译器创建的构造函数成为**合成的默认构造函数**。默认构造规则：
    1. 若存在类内初始值，则用它初始化。
    2. 默认初始化。
  - 一些情况下不能依赖于合成的默认构造函数
    1. 该类有其他以定义的构造函数
    2. 类中含部分内置类型或复合类型（如数组和指针），其被默认初始化的情况下，值是未定义的。
    3. 编译器不能为某些类合成默认的构造函数：如类中包含其他类类型的成员且这个成员的类型无默认构造函数。
  - 定义构造函数：
    - `=default`C++11中表示需要默认行为。在类的内部则默认构造函数是内联的，外部则不是。
    - `Sales_data (const std::string &s) : bookNo(s){}`括号中是构造函数初始值列表，与冒号后的成员对应。花括号为函数体，由于其作用仅为初始化数据，因此函数体为空。
    - 上一条中形式等价于`Sales_data (const std::string &s) : bookNo(s), units_sold(0), revenue(0){}`
    - 在类外也可以定义构造函数。
- 拷贝、赋值、析构
  - 编译器可以合成拷贝、赋值、销毁操作，但是类需要分配类对象之外的资源时（如管理动态内存）不能依赖合成版本。
  - 很多使用动态内存的类可以考虑使用vector对象或string对象来管理存储空间。

## 7.2 访问控制和封装

访问说明符 public private

struct和class唯一的区别就是默认的访问权限：struct在第一个访问说明符之前是public；class是private。

### 7.2.1 友元

友元类、函数可以访问非公有成员

友元声明只能在类内部，最好在类开始或结尾处集中声明。`friend ......`

注意，友元声明只是指定了访问的权限，如希望类用户能调用某友元函数，则要在友元声明之外再对函数进行一次声明。（部分编译器不强制要求，但是为了代码的普适性，还是推荐这样做）

友元不受所在区域访问控制级别约束

## 7.3 类的其他特征

### 7.3.1 类成员再探

定义在类内部的函数自动内联。

显式定义inline无须在定义和声明处同时说明。

可变数据成员：mutable

- 永远不会为const，即使是const对象的成员。

### 7.3.2 返回*this的成员函数

返回func1和func1 &的区别在于：

若返回的不是引用类型，则返回值为*this的副本而不是this本身，因此该函数只能改变临时副本，不能改变本身的值。

### 7.3.3 类类型

每个类定义唯一类型。即使两个类成员完全相同，两个类也不是同一个类。

声明方式：`Sales_data item1; //等价于 class Salas_data item1;`

类可以仅声明而暂时不定义，有时成为**向前声明**，声明之后定义之前是一个**不完全类型**

不完全类型在有限的情景下使用：

1. 指向这种类型的指针、引用
2. 声明其为不完全类型作为参数或者返回类型的函数

​	由于类被定义之前，数据成员不能被声明成该类型，而可以被声明成指向这种类型的指针、引用。

​	因此可以：

​	`class Link_screen{`

​	`Screen window;`

​	`Link_screen *next;`

​	`Link_screen *prev;`

​	`}`

## 7.4 类的作用域

一个类就是一个作用域

两个例子：

1. `void Window_mgr::clear(ScreenIndex i)`中ScreenIndex在类Window_mgr中。编译器在处理参数列表之前就已经明确了在Window_mgr作用域中。
2. `Window_mgr::ScreenIndex Window_mgr::addScreen()`返回类型在类名之前，因此其位于Window_mgr作用域之外。

### 7.4.1 名字查找与类的作用域

名字查找过程：

1. 在块内使用语句之前查找
2. 查找外层
3. 查找失败，程序报错

对定义在类内部的成员函数：

1. 编译成员的声明
2. 直到类全部可见后才编译函数体

​	成员函数体直到整个类可见后才会被处理，这样成员函数体不必只使用已经出现的名字，简化了代码组织方式

​	类成员声明中使用的名字，包括返回类型或参数列表中使用的名字，在使用前都要确保可见。

类型名不能在类中重新定义。（例如外层有 `typedef double money`,则类内不能再次出现 `typedef ... money`)。*编译器可能会通过编译，但代码仍存在错误*。

成员函数中使用名字按照如下方式解析：

1. 成员函数内查找该名字的声明。
2. 函数内没找到，类内继续查找。（类中所有成员）。
3. 类内无，则再成员函数定义之前的作用域内查找。

## 7.5 构造函数再探

### 7.5.1 构造函数初始化列表

构造函数可以不以初始化列表的形式初始化，这样的话构造函数对数据成员进行了赋值操作而非初始化操作。

在有些情况下上述方式会引起错误，例如：引用、const成员、属于某种未提供默认构造函数的类类型。

从底层效率和某些成员必须被初始化的角度来说，建议使用构造函数初始值。

构造函数初始值列表只用于说明初始化对象的值，不限定初始化顺序。（在用某些成员初始化其他成员的情况下可能出现错误）

### 7.5.2 委托构造函数

委托其他函数来完成其构造函数的任务。

执行顺序为：受委托的构造函数的初始值列表->受委托构造函数的函数体->委托者的函数体

### 7.5.3 默认构造函数作用

自动执行默认构造函数的情况：

- 被默认初始化：
  - 在块内，不使用任何初始值定义一个非静态变量或数组。
  - 类本身含有类类型成员且使用合成默认构造函数。
  - 类类型成员没有在构造函数初始值列表中显示初始化。
- 值初始化：
  - 数组初始化时提供的初始值数量小于数组大小。
  - 不使用初始值定义一个局部静态变量。
  - 形如T（）的表达式显示请求值初始化。

注意：使用默认构造函数的方法为：`Salas_data obj; //Salas_data obj();则意义是声明一个函数`

### 7.5.4 隐式的类类型转换

如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。（因此也成为转换构造函数）

只能允许一步类类型转换。

explicit关键字抑制构造函数定义的隐式转换

- 只对一个参数的构造函数有效。
- 只能在类内声明构造函数时使用explicit关键字。

为转换显式使用构造函数：

- `item.combine(Salas_data(null_book));`
- `item.combine(static_cast<Salas_data>(cin));`

标准库中含有显式构造函数的类：

- 接受一个单参数const char*的string构造函数不是explicit
- 接受一个容量参数的vector构造函数是explicit

### 7.5.5 聚合类

当类满足以下条件时，称为聚合类：

- 所有成员为public
- 没有定义构造函数
- 没有类内初始值
- 没有基类、virtual函数

用户可以直接访问其成员、有特殊的初始化语法。

如Data类有成员ival和s，则初始化为：`Data val1 = {0, "anna"};` 注意顺序必须与成员声明一致

初始化列表小于成员数量，则靠后的被值初始化；不能大于成员数量。

### 7.5.6 字面值常量类

1. 数据成员都是字面值类型的聚合类是字面值常量类
2. 符合以下要求的非聚合类：
   - 数据成员均为字面值类型
   - 类必须至少含有一个constexpr构造函数
   - 数据成员假如有类内初始值，则内置类型成员的初始值一定是常量表达式；如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数
   - 类必须使用析构函数默认定义，负责销毁类的对象

constexpr构造函数可以是 = default形式也可以是删除函数形式

否则，要同时满足构造函数要求和constexpr函数要求。因此constexpr构造函数体一般为空。 

## 7.6 类的静态成员

static声明静态成员

在外部定义静态成员时，不能重复static关键字

使用作用域运算符访问静态成员

静态成员类内初始化：

- 一般情况下不应类内初始化
- 可以为静态成员提供const整数类型的类内初始值，要求静态成员必须是字面值常量类型constexpr
- 即使类内已经初始化，通常在类外也定义。

静态数据成员可以是不完全类型。

静态成员可以作为默认实参。

