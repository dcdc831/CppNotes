# 第五章 语句

## 5.1 简单语句

简单语句、复合语句块

## 5.2 语句作用域

控制结构定义的对象值马上要由控制结构本身使用，因此这些变量必须初始化

## 5.3 条件语句

if switch

### 5.3.1 if语句

- 悬垂else：C++规定else与离其最近的尚未匹配的if匹配。
- 善用花括号控制执行路径

### 5.3.2 switch语句

case标签一定是<u>整型常量表达式</u>

- switch内部变量定义：

  可以定义，初始化则是非法行为。（隐式或显式均不可）

  （*定义在编译中检查*，因此是否执行该语句不影响定义的完成与否；*初始化是一条语句，只有程序执行才能完成*，所以初始化是可以被跳过的而定义不会）

  C++不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。

  解决方法可以把变量定义在一个块内。

## 5.4 迭代语句

### 5.4.1 while语句

### 5.4.2 for语句

init-statement可以定义多个对象，但只有一条声明语句

condition为空时，等价于在此写true

### 5.4.3 范围for语句

范围for的原理是传统for语句。

### 5.4.4 do while语句

condition使用的变量必须定义在循环体之外，不能在condition中定义变量。

## 5.5 跳转语句

### 5.5.1 break语句

作用范围是最近的循环或switch

### 5.5.2 continue语句

## 5.6 try语句块和异常处理

- throw语句表达式：引发异常
- try语句块：处理异常（catch子句处理）
  - try语句块中声明的变量在外部无法访问，即使在catch中也不行
- 异常类

# 第六章 函数

## 6.1 函数基础

调用函数时，假如需要形参，则我们需要提供一个可以转换成形参的数据类型的实参

形参列表<u>每个形参都要指出类型</u>

函数的返回类型不能是数组或函数类型，但可以是指向数组或函数的指针

### 6.1.1 局部对象

形参和函数体中定义的变量都是局部变量，对函数而言局部。

局部变量的作用域隐藏在外层作用域中同名的其他声明中。

- 自动对象：只存在于块执行期间的对象。块执行结束后自动对象就变成未定义的了。
- 局部静态对象：定义为static类型，程序路径第一次经过定义语句时初始化，程序终止时才销毁。

### 6.1.2 函数声明

无须函数体，无须形参的名字，也称*函数原型*

尽量在头文件中进行函数声明。

### 6.1.3 分离式编译

允许把程序放在几个文件中，分别独立编译。

## 6.2 参数传递

- 形参是引用类型：对应的实参被**引用调用**或函数被**传引用调用**
- 实参的值被拷贝给形参：形参与实参相互独立，实参被 **值传递**或函数被 **传值调用**

### 6.2.1 传值参数

C++中建议使用引用类型形参代替指针

### 6.2.2 传引用参数

尽量使用引用避免拷贝：

- 拷贝大的类类型对象和容器对象时低效
- 有点类类型（如IO）不支持拷贝操作

使用引用形参可以将形参看作额外的返回信息

### 6.2.3 const形参和实参

用实参初始化形参会忽略顶层const

最好将不会改变的形参定义成常量引用。否则其适用范围会减少，有些时候会发生难以察觉的问题

### 6.2.4 数组形参

- 不能以值传递的方式使用数组参数（数组不能拷贝）
- 传递数组时，实际上传递的是指向数组首元素的指针

数组以指针形式传递给函数，因此函数一开始不知道数组的确定尺寸，要通过其他方式管理指针形参：

1. 使用标记指定数组长度（如C风格字符串末尾）
2. 使用标准库规范（如begin、end）
3. 显式传递一个表示数组大小的形参

传递多维数组 假设要传 ` a[m][n]`

则函数声明为：`void func(int (*a)[n], int m) 或 void func(int a[][n], int m)`

### 6.2.6 含有可变形参的函数

- initializer_list形参（也是一种模板类型）
  - 向initializer_list形参中传递值得序列，必须把序列放在花括号里。

- 省略符形参：只能出现在形参列表最后得位置。为便于C++程序访问一些特殊的C代码设置的。


## 6.3 返回类型和return语句

### 6.3.1 无返回值函数

无返回值函数return后如果有expression，则一定是另一个返回void的函数；否则会出现编译错误

### 6.3.2 有返回值函数

返回的值用于初始化调用点一个临时量，该临时量即函数调用结果

不要返回局部对象的引用、指针

 调用返回引用的函数得到左值，其他情况得到右值

C++11规定，函数可以返回花括号包围的值得列表。列表为空时，临时量执行值初始化。

main函数假如不是void类型且没有return，编译器将隐式插入return 0；

### 6.3.3 返回数组指针

1. 方法一：类型别名

   `typedef int arrT[10];//等价于 using arrT = int[10];`

   `arrT *func(int i);`

2. 方法二：不用类型别名

   `int (*func(int i))[10];`<u>从内向外理解！</u>

3. 方法三：使用decltype

## 6.4 函数重载

名字相同，形参列表不同

- 顶层const不影响传入函数的对象，底层const则会影响。如 const int&、int *const

  - 因此形如const int 和int会导致重复声明func（int）；

  - 由于非常量可以转换成const，所以都能作用与非常量对象。传递非常量时，编译器会优先选择非常量版本函数。

调用一组重载函数需要一个函数匹配（重载确定）的过程。

### 6.4.1 重载与作用域

如果在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。不同作用域中无法重载函数名。

原因是C++中名字查找在类型检查之前，一旦在当前作用域中查找到所需名字，就不会向外继续查找。

## 6.5 特殊用途语言特性

### 6.5.1 默认实参

调用时可以包含该实参，也可以忽略。

调用时实参按位置解析，默认实参只能填补缺少的尾部实参。因此在设计时尽量将经常使用默认值的形参放在后面。

默认实参声明只能赋予一次，不能修改。通常在函数声明中指定默认实参，将该声明放在合适头文件中。

默认实参的求值发生在函数调用时。

### 6.5.2 内联函数和constexpr函数

inline 内联：运行时展开，适用于规模较小、流程简单、调用频繁的函数。

constexpr函数：函数的返回类型和所有形参类型必须为字面值类型，函数体必须只有一条return语句。

​	为了在编译过程中展开，constexpr函数被隐式指定为内联函数

### 6.5.3 调试帮助

assert 预处理宏 `assert(expr)`

## 6.6 函数匹配

1. 候选函数：与被调用函数同名，声明在调用点可见
2. 可行函数：形参数量与本次调用提供的实参数量相等，每个实参的类型与对应的形参类型相同。

寻找最佳匹配：基本思想时实参类型与形参类型越接近越好。

### 6.6.1 实参类型转换

## 6.7 函数指针

形如 `bool (*pf)(const string &, const string &);`

函数指针的使用：

- 函数名可以当作一个值使用：`pf = lengthcompare; // 等价于 pf = &lengthcompare; 取地址符可选。 pf指向名为lengthcompare的函数`

- 调用时，可以直接使用直接函数的指针调用该函数： `bool b1 = pf("helllo", "goodbye");`

- 指向不同函数类型的指针间不存在转换规则。

- 重载函数的指针，上下文必须清晰界定到底应该选用哪个函数。必须精确匹配。

- 函数形参列表中有函数时，自动转化为指针。把函数作为实参使用时，也会自动转换为指针。

- 定义返回类型为指向函数的指针：

  1. 使用类型别名：

     `using F = int(int *, int);`

     `using PF = int(*)(int *, int);`

     `PF f1(int); // 等价于 F *f1(int);`

  2. 直接声明：

     `int (*f1(int)) (int *, int);`

  3. 尾置返回类型：

     `auto f1(int) -> int(*) (int *, int);`





​                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
