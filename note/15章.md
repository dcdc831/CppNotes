# 第十五章 面向对象程序设计

## 15.1 面向对象：介绍

关键思想在于数据抽象、继承和动态绑定。

数据抽象：将类的接口和实现进行分离。

继承：定义概念上相互关联且类型相似的类。

动态绑定：在使用这些对象时忽略它们的细节上的不同。

#### 继承

通过继承关联起来的类组成了层级。通常层级的顶端是一个基类。

继承的类称之为派生类（derived classes）

基类定义层级中所类型都共通的成员，每个派生类定义特定于派生类自己的成员。

基类区分了每个类具有不同实现的函数与希望派生类只继承而不能做出改变的成员函数。基类将希望派生类定义自己的版本的函数为 `virtual` 的。

派生类需要指定其继承的类，指定方式使用类继承列表（class derivation list），即冒号后跟着一列由逗号分隔的基类，每个基类有一个可选的访问说明符（access specifier）。

```C++
class Bulk_quote : public Quote 
{
    public:double net_price(std::size_t) const override;
};
```

#### 动态绑定

通过动态绑定，可以使用相同的代码来平滑处理基类和派生类对象

`double print_total(std::ostream &os, const Quote &item, std::size_t n)`

item 是 Quote 的引用，调用函数时既可以传递 Quote 对象也可以传递 Bulk_quote 对象

 C++ 中，动态绑定发生在虚函数通过基类的引用或指针调用时。

## 15.2 定义基类和子类

### 15.2.1 定义基类

基类通常应该定义虚析构函数，即便不做任何工作，虚析构函数依然是需要的。

#### 成员函数继承

派生类需要覆盖掉其从基类继承来的定义，并提供自己的定义。

必须明确区分希望派生类覆盖的函数和希望派生类继承而不改变的函数。希望派生类覆盖的函数定义为 virtual 的。通过指针或引用调用虚函数，这个调用将是动态绑定的。根据引用或指针绑定的不同对象类型，不同版本的函数被调用。在基类中被定义为 virtual 的函数，其在派生类中隐式也是 virtual 的。

所有的非静态成员函数（除了构造函数）都可以是 virtual 的。

#### **访问控制和继承**

派生类可以使用基类的 public 成员，但是不能访问基类的 private 成员。基类将只允许派生类访问，而不允许其它用户代码访问的成员定义为 protected。

### 15.2.2 定义派生类

派生类必须指定从哪个类继承，类必须是在之前定义过的。基类名字前可以放置可选的访问说明符。

继承列表中的访问说明符将决定派生类的用户代码是否可以知道派生类从哪个基类继承而来。

#### **派生类中的虚函数**

派生类将在其覆盖的函数上包含 virtual 关键字，但是不是必须这么做。新标准允许派生类显式告知它将覆盖一个继承自基类的虚函数。它是通过在参数列表后指定 override 关键字，或者如果成员函数是 const 的或者有引用修饰符，那么就放在 const 或引用修饰符后。

#### **派生类对象和派生类到基类的转换**

一个派生类对象包含多个部分：包含派生类自己定义的成员的子对象，加上每一个基类的子对象。

可以把派生类对象当作基类对象一样使用，特别是，可以将基类对象的引用或指针绑定到派生对象的基类部分。

**派生类对象包含其基类的子对象是理解继承如何工作的关键。**

#### **派生类构造函数**

派生类必须使用基类构造函数来初始化基类部分。

```C++
Bulk_quote(const std::string &book, double p, std::size_t qty, double disc):
    Quote(book, p), min_qty(qty), discount(disc) { }
```

基类对象总是先初始化，然后是派生类的数据成员根据在类体中声明的顺序进行初始化。

#### **在派生类中使用基类成员**

派生类可以访问基类的 public 和 protected 成员。派生类的作用域被嵌套在基类的作用域中

#### **继承和静态成员**

如果在基类中定义了静态成员，那么整个继承层级中只有此成员的唯一定义,每个静态成员只存在一份实例。

静态成员遵循常规的访问控制。如果一个成员在基类中是 private 的，那么派生类将无法访问它。

#### 派生类的声明

声明中包含类的名字，但不包含派生列表：

`class Bulk_quote : public Quote;`

#### **被用作基类的类**

被用作基类之前必须定义而不能仅仅只声明。每个派生类都包含并且可能使用其从基类继承来的成员。这也隐式说明一个类不能派生它本身。

最具体的派生类将继承其直接基类的所有成员，直接基类中的成员包含它自己从它的基类中继承来的成员，以此类推到整个继承链的顶端。

最具体的派生对象将包含其直接基类的子对象以及每个间接基类的子对象。

### 15.2.3 转换和继承

通常，只能将引用和指针绑定到有相同类型的对象上，或者绑定到可以进行 const 转换的对象上。存在继承关系的类时一个例外：可以将基类的指针或引用绑定到这个类的派生对象上。

与内置指针一样，智能指针也支持派生类到基类的转换，可以将指向派生对象的指针存储到基类的智能指针。

#### **静态类型和动态类型**

表达式的静态类型在编译时就是已知的，它是变量声明时的类型或者表达式的结果类型。动态类型是变量或表达式所表示的在内存中的真正对象的类型，这个类型必须到运行时才能知道。

对于：

`double ret = item.net_price(n);`

item 的静态类型是 Quote&，动态类型则依据绑定到 item 的参数类型，运行时才能知道。

既不是引用也不是指针的表达式的静态类型和动态类型是一样的。

#### **没有从基类到派生类的隐式转换**

一个非派生类一部分的基类对象只包含基类定义的成员，并不包含派生类定义的成员。所以，并不存在从基类到派生类的自动转换。

即便基类指针或引用绑定到派生对象，其依然不能转为派生类。如：

```C++
Bulk_quote bulk;
Quote *itemP = &bulk;
Bulk_quote *bulkP = itemP;//错误！
```

编译器只能依据指针或引用的静态类型来判断转换是否是合法的。

#### **对象间不存在转换**

当初始化一个类对象时，将调用构造函数。当赋值时将调用赋值操作符。这些成员函数通常具有一个该类对象的 const 引用的参数。由于其参数接收引用，派生类到基类的转换允许我们传递一个派生对象给基类的拷贝/移动操作成员函数。

- 传递派生对象给基类构造函数时，基类中定义的构造函数将被执行。那个构造函数只能识别基类自己定义的成员，将一个派生对象赋值给基类对象，基类中定义的赋值操作符将被执行。那个操作符只能识别基类中定义的成员

- 用派生对象去初始化或赋值基类对象时，只有基类部分被拷贝、移动或赋值，派生类部分将被忽略。

理解存在继承关系的类之间的转换需要理解三点：

- 派生类到基类之间的转换仅被运用于指针或者引用类型；
- 没有隐式的从基类到派生类之间的转换；
- private 或 protected 继承的派生类有时不能执行派生类到基类的转换；

## 15.3 虚函数

C++ 的动态绑定发生在虚成员函数通过基类的引用或指针调用时发生。

必须给每个虚函数提供定义而不管它有没有被使用，因为编译器无法知道一个虚函数是否被使用。

#### **对虚函数调用可能在运行时解析**

当通过引用或指针调用虚函数时，编译器将生成代码可以在运行时决定具体调用哪个函数。

动态绑定只发生在虚函数通过指针或引用被调用的过程中。

```C++
Quote base = derived;
base.net_price(20);
```

上述代码就不会有动态绑定。

OOP 的关键思想是**多态**。**指针或引用的静态类型和动态类型可以不一样**的事实是 C++ 支持多态的基石。如果调用的函数是 virtual 的，那么决定调用哪个函数将推迟到运行时。调用的虚函数版本是指针或引用绑定的对象的类所定义的。

而通过对象进行的函数调用再编译时绑定（不管是不是虚函数）。

#### **派生类中的虚函数**

当派生类覆盖一个虚函数时，可以但不是必须提供 virtual 关键字，一旦一个函数被声明为 virtual ，它将在所有派生类中保持 virtual 。

覆盖继承的虚函数的派生类函数必须在派生类中**进行参数列表完全一致**的声明.

派生类中虚函数的返回类型必须与基类函数匹配。

例外是：派生类中的覆盖的虚函数可以返回一个基类中的返回类型的子类型的指针或引用。要求派生类到基类的转换可见，D如果由Bprivate派生而来，则 转换不可见。

#### **final 和 override 说明符**

在派生类中可以定义与基类中的虚函数同名的函数，但其参数列表不一样。并不覆盖基类中的版本。

在实践中，这种声明通常是错误的，类作者希望覆盖一个基类中的虚函数，但是写错误了参数列表。

新标准中可以在派生类的虚函数声明中指定 override 来明确表示是覆盖基类的虚函数。这样编译器就可以帮助我们进行检测。

```C++
struct B {
    virtual void f1(int) const;
    virtual void f2();
    void f3();
};
struct D1 : B {
    void f1(int) const override; //ok
    void f2(int) override; //错误：B 中没有 f2(int) 函数
    void f3() override; //错误：f3 不是虚函数
    void f4() override; //错误：B 中没有名为 f4 的函数
};
```

可以将函数指定为 final 的，任何尝试覆盖一个被声明为 final 的函数将被认为是编译错误。

#### **虚函数和默认参数**

当一个调用使用默认实参时，使用的默认值是调用此函数的对象的静态类型中所定义的默认值。

当通过基类的指针或引用进行调用时，使用基类中定义的默认实参。即使是绑定到派生类对象并且派生类的覆盖虚函数被调用，这个基类默认实参依然会被使用。

如果虚函数使用了默认实参，通常应该总是在派生类和基类中使用相同的实参。

#### **绕过虚函数机制**

通过使用作用域操作符可以调用虚函数的特定版本，调用解析发生在编译时：

```C++
//调用基类的版本，忽略 baseP 的动态类型
double undiscounted = baseP->Quote::net_price(42);
```

## 15.4 抽象基类

#### **纯虚函数**

 `Disc_quote` 类是通用的打折书的概念，而不是具体的策略。所以，应当阻止用户实例化此类的对象。

通过在函数参数列表后，分号前写上 = 0 来表明一个虚函数是纯虚函数。= 0 只能出现在类体内的虚函数声明处。

`double net_price(std::size_t) const = 0;`

可以给纯虚函数提供一个定义，然而，函数体必须在类外进行定义，不能类内给一个纯虚函数提供定义。

#### **含有纯虚函数的类是抽象基类**

抽象基类可以定义接口给派生类去覆盖。不能直接创建抽象基类的对象。从抽象基类继承的派生类必须定义所有纯虚函数，否则派生类也是抽象的。

#### **派生类构造函数只能初始化其直接基类**

构造函数先调用直接基类 Disc_quote 的构造函数进行初始化，这个构造函数先调用它自己的直接基类 Quote 的构造函数进行初始化，Quote 的构造函数执行完返回时，Disc_quote 构造函数将继续执行，并最终返回到 Bulk_quote 构造函数.

重构（refactoring）需要重新设计类继承体系，并将操作或数据从一个类移动到另一个类。

## 15.5 访问控制与继承

#### **受保护的成员**

protected 修饰那些对派生类可见，不被其他公共访问使用的成员。

派生类的成员和友元只能通过派生对象访问基类的 protected 成员。派生类不能访问独立的基类对象的 protected 成员。

```C++
class Base {
protected:
    int prot_mem;
};
class Sneaky : public Base {
    friend void clobber(Sneaky &); //可以访问 Sneaky::prot_mem
    friend void clobber(Base &); //不能访问 Base::prot_mem
    int j;
};
void clobber(Sneaky &s) { s.j = s.prot_mem = 0; }
//错误：clobber 不能访问 Base 中的 protected 成员
void clobber(Base &b) { s.prot_mem = 0; }
```

第二个函数不是 Base 的友元，因而，它不能访问 Base 对象的受保护成员。

#### **共有、私有和受保护的继承**

访问一个类继承来的成员是由基类中的访问说明符和派生列表中的访问说明符共同决定的。

![image-20220804104738431](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220804104738431.png)

派生访问说明符并不影响派生类的成员和友元对其直接基类的成员访问权限。

派生访问说明符的作用在于控制派生类的用户对从基类继承来的成员的访问权限，这些用户包括从这个派生继承的其它派生类。

```C++
Pub_Derv d1; //从基类中继承来的成员是 public 的
Priv_Derv d2; //从基类中继承来的成员是 private 的
d1.pub_mem(); //pub_mem 在 d1 中是可见的
d2.pub_mem(); //错误：pub_mem 在 d2 中是不可见的
```

当继承是 public 的，成员将保持其可见性，所以 d1 可以调用 pub_mem。而 Priv_Derv 中基类的成员是 private 的，此类的用户不能调用 pub_mem 。

派生类的派生访问说明符还会控制从此派生类进行继承的类对其基类的访问权限。

如果使用 protected 继承，Base 中的 public 成员在派生类中将变成 protected 的，其用户将不能访问继承来的成员，但是其子类可以访问这些成员。

#### **派生类到基类的转换的可见性**

假设 D 继承自 B：

- 仅当 D 是公有继承 B 时，用户代码可以使用派生类到基类的转换，若以 protected 或 private 继承则不可以；
- D 的成员函数和友元：可以使用派生类到基类的转换，而忽略 D 是如何继承 B 的，派生类到直接基类的转换对于派生类的成员和友元来说总是可访问的；
- D 的派生类的成员和友元：当 D 是 public 或 protected 继承 B 时，可以使用派生类到基类的转换。如果 D 是私有继承 B 则这种转换不可使用；

#### **友元关系和继承**

友元关系不会被继承。基类的友元对于派生类成员没有特殊的访问权限，派生类的友元对于基类成员没有特殊访问权限。

Pal 是 Base 的友元，所以 Pal 可以访问 Base 对象的私有成员，这种访问权限即便是当基类对象是其派生类对象的一部分时依然成立。

#### **改变单个成员的访问权限**

有时我们需要改变特定的派生类继承来的名字的访问级别。使用 using 声明来指定。

派生类不能改变基类的私有成员的访问级别，原因在于它们对派生类根本不可见。

```C++
class Base {
public:
    std::size_t size() const { return n; }
protected:
    std::size_t n;
};
class Derived : private Base {
public:
    using Base::size;
protected:
    using Base::n;
};
```

由于 Derived 使用了 private 继承，所以，size 和 n 默认是 Derived 的私有成员。using 声明调整了这些成员的可见性。Derived 的用户代码可以访问其 size 成员，Derived 的派生类可以访问 n 成员。

只能给它可以访问的基类名字使用 using 声明。

#### **默认继承的派生访问说明符**

用 class 定义的派生类默认是 private 继承；用 sturct 定义的派生类默认是 public 继承。它们之间唯一的区别就是成员的默认访问说明符和默认的派生访问说明符之间的不同。除此之外更无别的区别了。

最好给出访问说明符，不要使用默认的。

## 15.6 继承下的类作用域

每个类定义其自己的作用域，在其中它的成员被定义。在继承下，派生类的作用域被嵌套在基类的作用域中。

一个名字在派生类中无法被解析，那么将继续查找基类作用域。

#### **名称查找发生在编译期间**

对象、引用、指针的静态类型决定了哪些对象的成员是可见的。

```C++
Bulk_quote bulk;
Bulk_quote *bulkP = &bulk;
Quote *itemP = &bulk;
bulkP->discount_policy();
//错误：itemP 的类型是 Quote* ，它没有 discount_policy 成员
itemP->discount_policy();
```

#### **名称冲突和继承**

派生类可以复用其直接或间接基类的名字。与往常一样，定义在内部作用域的名字将隐藏定义在外部作用域的名字。

```C++
struct Base {
    Base() : mem(0) {}
protected:
    int mem;
};
struct Derived : Base {
    Derived(int i) : mem(i) {}
    //Base::mem 将被隐藏，返回的是本类自己定义的 mem
    int get_mem() { return mem; }
protectd:
    int mem;
};
```

#### **使用作用域操作符来访问被隐藏的成员**

通过使用作用域操作符可以访问被隐藏的基类成员

`int get_base_mem() { return Base::mem; }`

除了覆盖继承的虚函数外，派生类通常不应该复用基类中名字

`p->mem()` 的调用过程将发生以下步骤：

- 首先查看 p 的静态类型，调用成员函数的对象必须是类类型；
- 在静态类型的类中查找 mem 成员，如果没有找到，继续从其直接基类向上查找，直到找到或者最后一个基类被查找过，如果依然没有找到则产生编译错误；
- 一旦 mem 被找到了，执行常规的类型检查，查看函数原型与调用是否匹配，以及重载函数解析；
- 如果 mem 是虚函数，并且调用是通过引用或指针发生的，那么编译器将产生代码，其将执行在运行时根据被绑定的对象的动态类型调用不同的 mem 版本；
- 否则，如果 mem 是非虚函数，或者调用是通过对象实体（非引用或指针）发生的，编译器产生常规的函数调用代码；

#### 名字查找优先于类型检查

声明在内部作用域的函数将不会重载定义在外部作用域的函数。因而，定义在派生类中的函数不会重载基类中的成员函数。

即便在派生类中同名的成员是数据成员，也会隐藏基类中的同名函数。

#### **虚函数和作用域**

如果基类和派生类的同名成员的参数不一样，那么将无法通过基类的指针或引用调用派生类的版本。

## 15.7 构造函数与拷贝控制

### 15.7.1 虚析构函数

析构函数是 virtual 的，将允许继承层级中的对象可以被动态析构。如 `Quote*` 指针可能指向 `Bulk_quote` 对象，如果要让编译器成功调用 `Bulk_quote` 的析构函数，就必须让 Quote 的析构函数是虚函数。

```C++
class Quote {
public:
    //如果基类指针指向派生对象，
    //当被删除时，需要析构函数是虚函数
    virtual ~Quote() = default;
};
```

### 15.7.2 合成拷贝控制和继承

在基类和派生类中合成的拷贝控制成员与任何别的合成的构造函数、赋值操作符和析构函数是一样的：它们将逐成员初始化、赋值、销毁类的成员。

合成的成员将使用基类的对应操作初始化、赋值或销毁其直接基类子对象。如：合成的 Bulk_quote 默认构造函数将调用 Disc_quote 的默认构造函数，而 Disc_quote 则继续调用 Quote 的默认构造函数；

#### **基类和派生类中被删除的拷贝控制成员**

基类的定义方式将导致派生类的拷贝控制成员是被删除的函数。

- 如果基类的默认构造函数、拷贝构造函数或拷贝赋值操作符或析构函数是被删除的或者不可访问的，那么派生类的对应成员也被定义为被删除的函数；
- 如果基类有一个被删除的或不可访问的析构函数，那么派生类合成的默认和拷贝构造函数将是被删除的函数；
- 与往常一样，编译器不会合成被删除的移动操作。当使用 `= default` 来请求移动操作时，如果基类的对应操作是被删除的或者不可访问的，或者基类的析构函数是被删除的或不可访问的；

### 15.7.3 子类拷贝控制成员

派生类定义拷贝、移动操作，这些操作需要拷贝、移动整个对象，包括基类成员。

#### **定义派生拷贝、移动构造函数**

当定义派生类的拷贝、移动构造函数，通常需要调用基类对应的构造函数来初始化对象的基类部分。

#### **定义派生赋值操作符**

必须显式对基类部分进行赋值。

```C++
D &D::operator=(const D &rhs)
{
    Base::operator=(rhs);
    return *this;
}
```

此操作从显式调用基类的赋值操作符来对派生对象的基类部分进行赋值开始，基类操作符可以正确处理基类对象的赋值。一旦基类操作符完成后，将继续执行派生类自己的赋值操作。

#### **派生类的析构函数**

派生析构函数只需要销毁派生类自己分配的资源。

对象的销毁顺序与构造顺序刚好相反：派生析构函数先执行，然后基类构造函数被调用，沿着继承链一直往上执行析构。

#### **在构造函数和析构函数中调用虚函数**

派生对象中的基类部分先构建，当基类构造函数执行时，其对象的派生部分还没有初始化。而，派生对象的析构则是反方向的，所以，当基类的析构函数执行时，其派生部分已经被销毁了。所以，当基类的这两个成员执行时，对象是不完全的。

为了兼容这种不完全，当对象正在构造时，其类型被认为与构造函数所在类是一样的；调用虚函数会被解析为构造函数所在类的那个版本。这对于析构函数来说也是一样的。调用虚函数可以是直接调用，也可以是构造或析构函数调用的函数间接调用了这个虚函数。

### 15.7.4 继承的构造函数

在新标准中，派生类可以复用直接基类的构造函数。尽管，这不是常规意义上的继承。

只能继承来自直接基类的构造函数，并且派生类不会继承它的默认、拷贝和移动构造函数，原因是编译器会其合成这些构造函数。

通过 using 声明可以让派生类继承基类的构造函数：

```C++
class Bulk_quote : public Disc_quote {
public:
    using Disc_quote::Disc_quote;
    double net_price(std::size_t) const;
};
```

using 声明将导致编译器生成代码。编译器将生成与基类一一对应的构造函数.

## 15.8 容器和继承

当使用容器存储来自继承层次的对象时，通常得使用间接的方式存储对象。(不能在容器中持有不同类型的元素。)

由于对象被赋值给基类对象时是裁剪（sliced down）的，容器与有继承关系的类型不能很好的混合使用。

当使用容器来存储有继承关系的类型时，通常将容器定义为存储基类的**指针**或**智能指针**。



# 第十六章 模板与泛型编程

面向对象（OOP）和泛型编程（generic programming）都是处理在书写程序时未知的类型，所不同的是 OOP 处理直到运行时才知道的类型，而泛型编程则处理知道编译时才知道的类型。

模板（Template）是泛型编程的基石。

## 16.1 定义模板

为每个类型都定义相同的操作是十分繁琐的，而且需要知道所有操作的类型，更合理的方式是定义函数模板，然后在使用时提供类型即可。

### 16.1.1 函数模板

可以定义函数模板（function template）。函数模板是合成特定类型版本的蓝本。

```C++
template <typename T>
int compare(const T &v1, const T &v2)
{
    if (std::less<T>()(v1, v2)) return -1;
    if (std::less<T>()(v2, v1)) return 1;
    return 0;
}
```

从关键字 template 开始，后面跟着模板参数列表，这是放在尖括号中的一个逗号分隔的一个或多个模板参数。模板参数列表不能是空的。

#### **实例化函数模板**

调用函数模板时，编译器使用调用实参来推断模板实参。编译器使用实参的类型来决定绑定到模板参数 T 上的类型。这些编译器生成的函数被统称为模板的实例.

#### 模板类型参数

compare 函数具有一个模板类型参数

可以将类型参数当作一个类型说明符来使用，这与使用内置类型或类类型是一样的。

每个类型参数都可以被放在关键字 class 或 typename 之后。class 与 typename 在这种情况下是完全一样的，且可以互换。

#### **非类型模板参数**

除了可以定义类型参数，还是可以定义带有非类型参数的模板。非类型参数表示一个值而不是类型。非类型参数通过使用特定类型名字而不是 class 或 typename 来指定。

当模板被实例化时，非类型参数将被一个用户提供的值或者编译器推断的值替代。这些值必须是常量表达式。

```C++
template <unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    cout << N << std::endl;
    cout << M << std::endl;
    return strcmp(p1, p2);
}
compare("hi", "mom");
```

编译器将会使用字面量的长度替换 N 和 M 非类型参数来实例一个模板版本。

```C++
int compare(const char (&p1)[3], const char (&p2)[4]);
```

一个非类型参数可能是整数类型、函数或对象的指针或左值引用。

- 绑定到整型的实参必须是常量表达式
- 绑定到指针或引用的实参必须具有静态生命周期，不能使用常规本地对象或动态对象的地址或引用作为实参，指针参数还可以被实例化为 nullptr 或零值常量表达式

#### **内联和 constexpr 函数模板**

函数模板可以与常规函数一样被声明为 inline 或 constexpr 的，inline 或 constexpr 关键字放在模板参数列表后，在返回类型前：

`template <typename T> inline T min(const T &, const T &);`

#### **模板编译**

编译器并不是遇到模板定义时生成代码，而是在实例化特定版本的模板时生成代码。

为了生成实例，编译器需要知道函数模板的定义以及类模板成员函数的定义。因而，与非模板代码不同，模板代码的头文件中通常包含声明和定义。

#### **编译错误大部分在实例化期间发现**

1. 当编译器模板本身时，可以发现一些语法错误； 
2. 当编译器发现模板被使用时，会检查是否参数数目与模板定义一致；
3. 与第二个阶段几乎是在一起发生的，在实例化期间，可以发现类型相关的错误（不存在的操作），取决于编译器如何管理实例，这些错误可能在链接期间被发现。

### 16.1.2 类模板

类模板是合成类的蓝本。

#### 定义模板类

![image-20220804165413818](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220804165413818.png)

与函数模板一样，类模板以关键字 template 跟随模板参数列表。在类模板的定义中（包括成员定义），可以如使用常规类型或值一样使用模板参数，这些模板参数将在使用时被提供实参。

#### **实例化类模板**

当使用类模板时，必须提供额外的信息，这个额外信息就是显式模板实参

`Blob<int> ia;`

编译器为每一个不同的元素类型生成不同的类

#### **在模板作用域中实例化一个模板类型**

类模板名字不是类型的名字。一个类模板被用于实例化类型，而实例化的类型总是包含模板的实参。

#### **类模板的成员函数**

与常规函数一样，可以给类模板在类体内或类体外定义成员函数。同样，定义在类体内的成员函数是隐式内联的。类模板的成员函数本身是常规函数。然而，类模板的每个实例都有自己的成员版本。因而，每个类模板的成员函数具有与类模板一样的模板参数。

```C++
template <typename T>
void Blob<T>::check(size_type i, const std::string &msg) const
{
    if (i >= data->size())
        throw std::out_of_range(msg);
}
```

与其它定义在类模板外的成员函数一样，构造函数也是先声明类模板的模板参数。

```c++
template <typename T>
Blob<T>::Blob(): data(std::make_shared<std::vector<T>()) { }
```

#### **实例化类模板成员函数**

默认情况下，类模板的成员函数只有在程序使用模板函数时才会实例化。如果一个成员函数没有用到，那么就不会被实例化。成员只有在使用到时才会实例化的事实，使得我们可以实例化一个类，其使用到的类型实参只符合模板操作的部分要求。通常，一个类模板实例化类的成员只有在使用时才会被实例化。

#### **简化在类代码中使用模板类名**

在类模板自身的作用域中，可以使用模板名而不需要实参。

即：

```c++
template <typename T> class BlobPtr {
public:
    BlobPtr& operator++();// 与以下代码是一样的： BlobPtr<T>& operator++();
};
```

#### **在类模板体外使用类模板名字**

当在类模板体外定义成员时，必须记住直到看到类名时才处于类地作用域中。

```c++
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int)
{
    BlobPtr ret = *this;
    ++*this;
    return ret;
}
```

由于返回类型出现在类作用域的外面，所有必须告知返回类型是 BlobPtr 以其类型参数为实参的实例。

#### **类型模板和友元**

当一个类包含一个友元声明时，类与友元各自是否为模板是相互无关的。

#### 一对一友好关系

最常见的友元形式就是一个类模板与另一个模板（类或函数）的对应实例之间建立友元关系。

```c++
template <typename> class BlobPtr;
template <typename> class Blob;
template <typename T>
bool operator==(const Blob<T>&, const Blob<T>&);
template <typename T> class Blob {
friend class BlobPtr<T>;
friend bool operator==<T>(const Blob<T>&, const Blob<T>&);
};
```

为了指定模板（类或函数）的特定实例，我们必须首先声明模板本身。模板的声明包括模板的模板参数列表。

友元声明使用 Blob 的模板参数作为它们的模板实参。因而，这种友元被严格限定在具有相同类型的模板实参的 BlobPtr 和相等操作符的实例之间。

#### **通用和特定的模板友元**

一个类可以让另一个模板的所有实例都是其友元，或者将友元限定在某一个特定的实例。

![image-20220804172805257](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220804172805257.png)

为了让所有的实例都是友元，友元的声明中所使用的模板参数必须与类模板所使用的不一样

#### **与模板本身的类型参数成为友元**

在新标准中，可以使得模板的类型参数成为友元

```c++
template <typename Type> class Bar {
friend Type;
};
```

#### **模板的类型别名**

可以定义一个 typedef 来作为实例化类的别名

`typedef Blob<string> StrBlob;`

在新标准下可以用 using 声明来指定类模板的别名。如：

```C++
template <typename T> using twin = pair<T, T>;
twin<string> authors; 
```

模板类型别名是一族类的别名。当定义模板类型别名时，可以固定一个或多个模板参数，如：

```c++
template <typename T> using partNo = pair<T, unsigned>;
partNo<string> books;
partNo<Vehicle> cars;
partNo<Student> kids;
```

#### **类模板的静态成员**

与其它类一样，类模板可以声明静态成员（static members）。

每个类实例必须只有一个 static 数据成员的定义。

在定义静态数据成员时与在类外定义成员函数类似。