# 第二章 变量与基本类型



## 2.1基本内置类型

- 包括 **算数类型**和 **内置类型	**

​	算数类型包含 整形 浮点型

​	char 8位	wchar_t 16位	char16_t 16	char32_t 32

​	char16_t 16	char32_t 32 为Unicode字符集服务。

​	long long在C++ 11中定义的

​	unsigned type无符号类型（unsigned默认为unsigned int）

​	**char分为 char、signed char、unsigned char	**

- 类型转换

  - 假如赋给无符号类型一个超出范围的值，结果是初始值对无符号类型表示数值总数取模后的余数

    例如 -1赋给unsigned char -1是111111111，最后unsigned char的值为255（1111 1111）

  - 赋给带符号类型一个超出范围的值，结果为 undefined。结果无法预知。

  - 带符号和无符号类型不要混用。表达式同时出现两者时会转换成无符号数。

- 字面值常量（literal）

  - 十进制字面值类型 int、long、long long 尺寸最小匹配
  - 八进制和十六进制 int、unsigned int、long、unsigned long、long long、unsigned long long 尺寸最小匹配
  - short没有对应literal
  - 默认浮点字面值是double
  - 单引号：char型字面值 ‘a’；双引号：字符串型字面值"Hello world"（编译器自动添加\0），是由常量字符组成的数组
  - 转义序列
    - \n \t等
    - 泛化转义序列 \x紧跟十六进制数、\紧跟1、2、3个八进制数。
  - 添加后缀可以改变literal的默认类型。
  - bool字面值 true false；指针字面值 nullptr

## 2.2 变量

变量是提供一个**具名的、可供程序操作**的**存储空间**

本书中**对象**只是具有某种数据类型的内存空间

### 2.2.1 变量定义

- 初始化

  初始化与赋值都用 = 表示，但是二者是不同的操作（赋值是把对象当前值擦除，并用新值替换）

- 列表初始化

  int a{x}；当初始值有丢失信息风险时，编译器会报错。

- 默认初始化

  定义在函数体之外的变量初始化为0；定义在函数体内部的内置类型变量不被初始化（不能被访问）

  - 类自己决定其初始化对象方式：是否允许不初始化就定义，且若允许，默认初始值是多少。例如 string没有指定则生成空串。

### 2.2.2 变量声明与定义关系

声明规定变量类型与名字；定义在此基础上申请了存储空间、可能赋初值。

`extern int i；//声明`

`int i = 3; //定义`

### 2.2.4 名字的作用域

嵌套的作用域：内层的作用域可以使用外层中声明的名字；允许在内层重新定义外层作用域已有的名字。

## 2.3 复合类型

### 2.3.1 引用（左值引用）

`int &refVal = ival；`

定义引用时，会把引用和初始值绑定在一起（bind），且初始化完成后引用将与初始值对象一直绑定，无法重新绑定。

因此引用必须初始化。

**引用即别名**，对其所有操作都是在绑定的对象上进行的。

不能定义引用的引用（？）`int &refVal = refVal；`是可以通过编译的，`&&refVal` 无法通过编译。

引用类型要与对象**严格匹配**，不能和字面值或表达式值绑定。

*有标识的是左值*

### 2.3.2 指针

- 指针的特点
  - 指针自己是个对象，可以进行赋值、拷贝等访问，也可以先后指向不同对象。
  - 不一定需要定义时赋初值。（在块作用域中，不初始化会有个不确定的值）

- 定义：int *ip1, *ip2;

- 获取对象地址，要用**取地址符**&： int *ip1 = &ival;

- 不能定义指向引用的指针`int &*r = &p;`这种形式

  - 要理解r的类型到底是什么，就简单的方法是从右向左阅读r的定义，

    `int i = 42;`

    `int *p;`

    `int *&r = p;`

    1. 离变量名最近的符号对变量的类型有最直接的影响（此例中是&r的符号是&），因此r是一个引用。
    2. 声明符的其余部分以确定r引用的类型是什么，此题中的符号*说明r引用的是一个指针。
    3. 最后，声明的基本数据类型部分指出r引用的是一个int指针，即r是指向int型指针的引用

- 除少数情况外，指针类型与指向对象严格匹配。

  - void* 指针：可以存放任意类型对象的地址。不能直接操作void*指针所指的对象。
  - 指向常量的指针：可以指向非常量。如dval是一个变量，则 `const double *cptr = &dval;`是合法的。

- 不能访问无效指针；访问不指向具体对象的指针也不允许。

- 利用指针访问对象：**解引用符***

- 空指针

  - 生成方法：`int *p1 = nullptr; int *p2 = 0; int *p3 = NULL;`
  - nullptr可以被转换成其他任意指针类型。
  - NULL是预处理变量，值为0（头文件cstdlib中定义）。新标准下最好用nullptr而非NULL。
  - `int zero = 0; int *p2 = zero;`是非法的，不能把变量直接赋给指针，即使值为0。

- **建议初始化所有指针！**

问题：给定一个指针，如何判断这个指针是否已经指向一个合法的对象？

智能指针：`shared_ptr::operator bool(); weak_ptr::expired();`

### 2.3.3 理解复合类型的声明

变量的定义包括一个基本数据类型和一组声明符。

一般把修饰符和变量标识符写在一起：`int p1, *p2, *p3;`

- 指向指针的指针 `int **p1;`
- 指向指针的引用 `int *&p2;`

## 2.4 <u>const限定符</u>

定义常量，必须初始化且不能被修改。

默认情况下，const对象只在文件内有效。编译器在编译过程中把该变量替换为对应的数值。

若想在多个文件之间共享const对象，必须在定义时加extern关键字： `extern const in bufSize = fcn();`

### 2.4.1 const引用

`const int ci = 1;`

`const int &r1 = ci;`

不能修改所绑定对象。常量引用是个缩略词，其实不存在常量引用，引用不是对象，无法保持其不变。

对const的引用绑定时生成了一个临时量对象，而r1正是绑定了该临时量对象。

对const的引用可能引用一个非const对象。

### 2.4.2 指针和const

- 指向常量的指针pointer to const：`const double *cptr = &pi`

​		其中`pi`可以是常量也可以是变量，但在任何情况下，都不能通过cptr指针修改`pi`的值

- 常量指针const pointer：`int *const curErr`

  必须初始化，初始化完成后，其指向的地址不会发生变化。

### 2.4.3 顶层const

- 顶层const（top-level const）指针本身是个常量。顶层const能指：算数类型、类、指针等。
- 底层const（low-level const）指针所指对象是个常量

当执行对象的拷贝操作时，顶层const与底层const区别明显：

- 顶层const不受什么影响。（拷贝操作不会影响被拷贝对象的值）
- 底层const收到很多限制：
  - 拷入和拷出对象要用相同的底层const资格。
  - 一般非常量能转化成常量。

### 2.4.4 constexpr和常量表达式

- **常量表达式**：值不会变，且在编译过程中就能得到计算结果的表达式

  对象是不是常量表达式同时由它的数据类型和初始值共同决定。

- **constexpr变量**：若认定变量为常量表达式，则声明成constexpr类型。

- 声明constexpr时用到的类型必须是字面值类型：算数类型、引用和指针

- constexpr的初始值一定为nullptr或0，或存储于某个固定地址中的对象（一般函数体内定义的变量并非存在固定地址中）。

## 2.5 处理类型

### 2.5.1类型别名

typedef定义类型别名

别名声明定义类型别名：`using Dou = double;`

`typedef char *pstring; //pstring是char *的别名`

`const pstring cstr = 0;//理解为pstring是指向char的常量指针，不能改变指向地址，指向的内容可以改变`

### 2.5.2 auto类型说明符

编译器通过初始值推算变量的类型。

auto一般会忽略顶层const，若希望推断出的类型是顶层const，则要自己指出const，如 `const auto f = ci;`

### 2.5.3 decltype类型指示符

decltype返回改变量类型（包括顶层const和引用在内！这点与auto不同）

如果一个表达式的内容是解引用操作，那么将得到引用类型：`decltype(*p) c;//有语法错误，c是引用类型，需要初始化`

## 2.6 自定义数据结构

`struct Sales_data`

`{`

​	`string bookNo;`

​	`unsigned units_sold = 0;`

​	`double revenue = 0.0;`

`};`

- 预处理器

- 头文件保护符

  #ifdef / #ifndef

  #endif

# 第三章 字符串、向量和数组

## 3.1 命名空间的using声明

`using namespace::name`

**注意**：头文件不应该包含using声明。可能引起一些名字冲突。

## 3.2 标准库类型string

`#include<string>`

`using std::string`

### 3.2.1 定义和初始化string对象

 ![image-20220625103805635](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220625103805635.png)

- 直接拷贝和拷贝初始化

  用等号初始化实际上执行的是拷贝初始化；如果不用等号则是直接初始化。

### 3.2.2 string对象上的操作

![image-20220625104148443](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220625104148443.png)

- 读写string对象：使用IO操作符读写string对象。忽略开头的空白、直至遇到下一处空白。
- 使用getline读一行：`getline(cin, line); //读入内容直到遇到换行符（换行符不存入）`
- size函数返回的值类型为string::size_type类型，是 **无符号数** ，因此出现在表达式中时需要注意混用的情况。
- 比较：
  1. 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。
  2. 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

- 相加是左侧与右侧串接
- 字面值与string可以相加，但要保证每个+两侧必须至少一个对象是string（*字符串字面值与string是不同类型*）

### 3.2.3处理string对象中的字符

<img src="C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220625110716321.png" alt="image-20220625110716321" style="zoom: 80%;" />

- 处理每个字符：范围for

  `for(declaration : expression)// 如：for(auto c : str)` 

  `statement;`

  注意要想改变string中的字符时，要用**auto &c** 

## 3.3 标准库类型vector

vector是一种类模板

`vector<type> name`

不存在包含引用的vector（引用不是对象）

### 3.3.1 定义和初始化vector对象

![image-20220625161222765](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220625161222765.png)

最常见的方式就是先定义一个空vector，然后取到元素值后逐一添加。

初始化用花括号时，如果确认无法执行列表初始化，则编译器会尝试使用默认值初始化vector对象，即：

`vector<string> v7{10};//等价于vector<string> v7(10)`

### 3.3.2 向vector对象中添加元素

成员函数push_back函数，向尾端压进数据。

vector对象**能高效增长**，因此不需要提前指定容量。

若循环体内包含向vector对象添加元素的语句，则不能使用**范围for**循环。

### 3.3.3 其他vector操作

![image-20220625163943420](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220625163943420.png)

比较与string的比较一致

不能用*下标*的形式添加元素；只能对确认已存在的元素执行下标操作！（确认下标合法的一种手段就是尽可能用范围for语句）

​	否则会出现缓冲区溢出。

## 3.4 迭代器

所有标准库容器都可以使用迭代器，但只有少部分支持下标运算符。

### 3.4.1 使用迭代器

- 有迭代器的类型拥有begin和end成员

  - begin返回指向第一个元素的迭代器

  - end返回指向容器尾元素下一位置的迭代器
  - 容器为空时，两者都返回尾后迭代器

- 迭代器运算符

  ![image-20220625172607191](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220625172607191.png)

  for循环中，尽量使用 == 或者 !=；（大多标准容器的迭代器都没定义<、> 等运算符）

  只有支持随机访问的迭代器才能使用++、--

- 迭代器类型

  - 用iterator或者const_iterator来表示迭代器类型
  - vector或string对象是常量时，只能使用const_iterator

-  某些对vector的操作会使迭代器失效

  - 不能在范围for循环中向vector对象添加元素
  - 任何一种可能改变vector对象容量的操作会使vector对象的迭代器失效

- 迭代器算术运算

  ![image-20220625193814774](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220625193814774.png)

  iter1-iter2的计算结果类型为difference_type，是带符号整数（可正可负）

## 3.5 数组

数组与vector类似但是不相同，数组大小确定，不能随意添加元素。

### 3.5.1 定义和初始化内置数组

维度必须是**常量表达式**

必须指定数组类型，<u>不能用auto！</u>

- 显示初始化数组用 `= { }`

- 用字符串字面值初始化时，会自动添加空字符，注意数组维数是否足够

- 不允许拷贝和赋值

- 复杂的数组声明

  最好**由内往外**理解

  ![image-20220625195818633](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220625195818633.png)

### 3.5.3 指针和数组

对数组元素使用取地址符可以得到指向该元素的指针

很多用到数组名的地方，编译器会将其自动替换为指向数组首元素的指针。

使用数组作为auto变量初始值时，推断得到的类型是指针而非数组；用decltype时，返回的类型是数组。

**指针也是一种迭代器**

可以获取数组尾元素后那个并不存在元素的地址：`int *e = &arr[10];//arr维度为10`

begin和end

1. 是标准库函数，使用方法是将数组作为他们的参数
2. 返回的是指针

## 3.6 多维数组

实际上是数组的数组

范围for语句处理多维数组时，为避免数组被自动转化为指针，除了最内从循环，其他外层循环的控制变量都应该用引用类型。

# 第四章 表达式

## 4.1 基础

- 左值和右值
  - 对象被当作右值的时候：用到的是对象的值
  - 左值：用到的是对象的身份（在内存中的位置）
  - 在需要右值的情况下可以用一个左值来替代，实际使用的是它的值。

有大致以下情况：

- 赋值运算符需要一个非常量左值作为左侧运算对象，结果仍是左值
- 取地址符作用于左值运算对象，得到指向该对象的指针，此指针是右值
- 内置解引用符、下标运算符、迭代器解引用符、string和vector的下标运算符求值结果为左值
- 内置类型和迭代器的递增运算符得到的结果也是左值

## 4.2 算术运算符

![image-20220626153326706](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220626153326706.png)

参与取余运算一定是整数类型

C++11标准规定商无论正负都向0取整

m%n的结果符号与m相同（不为0时）

## 4.3 逻辑和关系运算符

![image-20220626154500625](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220626154500625.png)

- 逻辑与或运算符
  - 短路求值：先求左侧的值，左侧值不能确定表达式值的时候再求右侧值

## 4.4 赋值运算符

左右侧类型不同，右侧转化为左侧类型

满足右结合律

赋值运算返回其左侧运算对象

赋值运算的优先级较低

## 4.5 递增递减运算符

除非必须，否则不用后置版本

## 4.6 成员访问运算符

点运算符和箭头运算符：`ptr->mem等价于(*ptr).mem `解引用符的优先级低于点运算符，因此要加括号

## 4.7 条件运算符

条件运算符的两个表达式如果都是左值或能转成同一种左值类型时，运算结果为左值，否则为右值

条件运算符可以嵌套，满足左结合。

条件运算符优先级很低，通常要括号括起来。

## 4.8 位运算符

![image-20220626171632516](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220626171632516.png)

运算对象如果是小整型，则值会被自动提升

移位运算符优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符高

## 4.9 sizeof运算符

`sizeof(type)或sizeof expr`

在第二种形式中sizeof不实际计算运算对象的值，所以即使 `sizeof *p`中p时一个无效指针，也不会有什么影响

sizeof对数组执行时，得到整个数组所占空间的大小（不会把数组转换成指针）

## 4.10 逗号运算符

先对左侧表达式求值，然后丢弃求值结果，最终结果是右侧表达式。

## 4.11 类型转换

### 4.11.1 算术转换

把一种算术类型转换成另一种类型。运算符的运算对象将转换成最宽的类型。

- 整型提升：小整数类型转换成大整数类型

- 无符号运算对象

  - 一个带符号，一个无符号，且无符号类型不小于带符号，则转化为无符号。

  - 带符号大于无符号：依赖于机器

### 4.11.2 其他隐式类型转换

- 数组转换成指针；decltype、取地址、sizeof、typeid时不会发生
- 指针的转换
- 转换成布尔类型
- 类类型定义的转换

### 4.11.3 显式转换

- 命名的强制类型转换：`cast-name<type>(expression)`
  - static_cast：不包含底层const，都可使用static_cast（比如可以找回存在于void*中的值）
  - const_cast：去掉const性质，常用于有函数重载的上下文中
  - reinterpret_cast：为运算对象的位模式提供较低层次上的重新解释

## 4.12 运算符优先级表

![image-20220626211409752](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220626211409752.png)

![image-20220626211417525](C:\Users\18265\AppData\Roaming\Typora\typora-user-images\image-20220626211417525.png)

















 